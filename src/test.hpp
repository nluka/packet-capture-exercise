#ifndef CPPLIB_TEST_HPP
#define CPPLIB_TEST_HPP

#include <algorithm>
#include <fstream>
#include <iostream>
#include <vector>

#include "on-scope-exit.hpp"

// Module for writing tests for your code.
namespace test {

// Configuration:
#define TEST_THREADSAFE_REGISTRATION_AND_EVALUATION 1
#define TEST_THREADSAFE_ASSERTS 0

// Convenience macro which creates and registers a test suite.
#define SETUP_SUITE(name) \
test::Suite s(name); \
auto const registerSuiteOnScopeExit = make_on_scope_exit([&s](){ \
  test::register_suite(std::move(s)); \
});

// Convenience macro which creates a "using" statement, a test suite,
// and automatically registers the created test suite at the end of the
// current scope.
#define SETUP_SUITE_USING(func) \
using func; \
SETUP_SUITE(#func)

// Convenience macro which generates a generic name for an assertion.
#define CASE(expr) (#expr), (expr)

// Controls whether results are printed to the standard output.
void use_stdout(bool);

// Registers a file to output results to.
// No file is generated by default.
void set_ofstream(std::ofstream *);

// Sets the indentation sequence for printed assertions.
void set_indentation(char const *);

// If true, passing assertions will be printed - they are not printed by default.
// Failing assertions are always printed.
void set_verbose_mode(bool);

// A named collection of assertions.
class Suite {
private:
  class Assertion {
  public:
    Assertion() = delete;

    // A copy of `name` is made, so you don't have to worry about lifetimes!
    Assertion(char const *name, bool expr);

    [[nodiscard]]
    std::string const &name() const noexcept;

    [[nodiscard]]
    bool expr() const noexcept;

  private:
    std::string m_name;
    bool m_expr;
  };

  std::string m_name;
  std::vector<Assertion> m_assertions{};

public:
  Suite() = delete;

  // A copy of `name` is made, so you don't have to worry about lifetimes!
  Suite(char const *const name);

  // A copy of `name` is made, so you don't have to worry about lifetimes!
  Suite(std::string const &name);

  // Adds an assertion to this suite.
  // You can use the convenience macro `CASE` to generate a generic `name` automatically.
  // `expr` is your assertion which you want to be true, for example: add(1, 2) == 3.
  // If `TEST_THREADSAFE_ASSERTS` is non-zero, this operation is threadsafe.
  void assert(char const *const name, bool const expr);

  // This is called internally, you aren't required to do this!
  // But if you want, you can print the output of all currently stored assertions.
  void print_assertions(std::ostream *os) const;

  [[nodiscard]]
  std::string const &name() const noexcept;

  // Returns the number of currently stored assertions which are passing.
  [[nodiscard]]
  size_t passes() const noexcept;

  // Returns the number of currently stored assertions which are failing.
  [[nodiscard]]
  size_t fails() const noexcept;
};

// Registers a suite for later evaluation by `test::evaluate_suites`.
// Takes an r-value reference - the passed suite will be cannibalized!
// If `TEST_THREADSAFE_REGISTRATION_AND_EVALUATION` is non-zero,
// this operation is threadsafe.
void register_suite(Suite &&);

// Evaluates all currently registered suites prints their results.
// After evaluation, all suites are cleared.
// If `TEST_THREADSAFE_REGISTRATION_AND_EVALUATION` is non-zero,
// this operation is threadsafe.
void evaluate_suites();

// Returns the total number of assertions passed.
size_t assertions_passed();

// Returns the total number of assertions failed.
size_t assertions_failed();

} // namespace test

#endif // CPPLIB_TEST_HPP
